!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.yetanotherstore=t()}(this,function(){"use strict";function e(t){return t?(t^16*Math.random()>>t/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,e)}class t{constructor(e=!0){this._events={},this._enabled=e,this._eventIndex={}}countEvents(e){return e in this._events?this._events[e].length:0}disableEvents(){this._enabled=!1}enableEvents(){this._enabled=!0}on(t,s){if("function"==typeof s){t in this._events||(this._events[t]=[]);let n=e();return this._eventIndex[n]={eventName:t,callback:s},this._events[t].push(n),n}return console.warn("The callback must be of type Function"),null}emit(e,t=[]){if(this._enabled&&e in this._events&&this._events[e].length>0){const s=this._events[e];for(let e=0;e<s.length;e+=1)this._eventIndex[s[e]].callback(...t)}}async emitAsync(e,t=[]){if(this._enabled&&e in this._events&&this._events[e].length>0){const s=this._events[e];for(let e=0;e<s.length;e+=1)await this._eventIndex[s[e]].callback(...t)}}delete(e){if(!(e in this._eventIndex))return void console.log(`No event of id ${e}.`);let t=this._events[this._eventIndex[e].eventName],s=t.indexOf(e);delete this._eventIndex[e],-1!==s&&t.splice(s,1),0===t.length&&delete this._events[this._eventIndex[e].eventName]}}return class extends t{constructor(){super(),this._storage={},this._gateKeeper=null,this._locked=!1}set(e,t,s=!1){if(this._locked&&!s)return;if("object"==typeof e)throw new Error("Keys cannot be object");let n=e.toString(),i={key:n,value:t};return this._gateKeeper&&!this._gateKeeper(e,t)?this.emit("refused",[i]):(i.previousValue=this._storage[n],this._storage[n]=t,this.emit("valueSet",[i]),this.emit(`set:${n}`,[i]),n)}async setAsync(e,t,s=!1){if(this._locked&&!s)return;if("object"==typeof e)throw new Error("Keys cannot be object");let n=e.toString(),i={key:n,value:t};if(!this._gateKeeper||this._gateKeeper(e,t))return i.previousValue=this._storage[n],this._storage[n]=t,await this.emitAsync("valueSet",[i]),await this.emitAsync(`set:${n}`,[i]),n;await this.emitAsync("refused",[i])}get(e){let t=e.toString();return this._storage[t]}delete(e){let t=e.toString();if(t in this._storage){const e={key:t,value:this._storage[t]};return delete this._storage[t],this.emit("valueDeleted",[e]),this.emit(`del:${t}`,[e]),!0}return!1}async deleteAsync(e){let t=e.toString();if(t in this._storage){const e={key:t,value:this._storage[t]};return delete this._storage[t],await this.emitAsync("valueDeleted",[e]),await this.emitAsync(`del:${t}`,[e]),!0}return!1}has(e){return e.toString()in this._storage}reset(){this._storage={},this.emit("reseted",[])}async resetAsync(){this._storage={},await this.emitAsync("reseted",[])}keys(){return Object.keys(this._storage)}values(){return Object.values(this._storage)}setGateKeeper(e){"function"!=typeof e&&null!==e||(this._gateKeeper=e)}isLocked(){return this._locked}lock(){this._locked=!0}unlock(){this._locked=!1}async onSet(e,t){return await this.on(`set:${e}`,t)}async onDelete(e,t){return await this.on(`del:${e}`,t)}}});
